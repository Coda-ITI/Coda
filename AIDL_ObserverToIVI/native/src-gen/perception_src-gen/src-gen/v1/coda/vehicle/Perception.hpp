/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.2.15.v202410041619.
* Used org.franca.core 0.13.1.201807231814.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#ifndef V1_CODA_VEHICLE_PERCEPTION_HPP_
#define V1_CODA_VEHICLE_PERCEPTION_HPP_




#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#define HAS_DEFINED_COMMONAPI_INTERNAL_COMPILATION_HERE
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <cstdint>

#if defined (HAS_DEFINED_COMMONAPI_INTERNAL_COMPILATION_HERE)
#undef COMMONAPI_INTERNAL_COMPILATION
#undef HAS_DEFINED_COMMONAPI_INTERNAL_COMPILATION_HERE
#endif

namespace v1 {
namespace coda {
namespace vehicle {

class Perception {
public:
    virtual ~Perception() { }

    static inline const char* getInterface();
    static inline CommonAPI::Version getInterfaceVersion();
    
    struct GearState : CommonAPI::Enumeration< uint8_t> {
        enum Literal : uint8_t {
            PARK = 0,
            DRIVE = 1,
            NORMAL = 2,
            REVERSE = 3
        };
    
        GearState()
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(Literal::PARK)) {}
        GearState(Literal _literal)
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint8_t>(Literal::PARK):
                case static_cast< uint8_t>(Literal::DRIVE):
                case static_cast< uint8_t>(Literal::NORMAL):
                case static_cast< uint8_t>(Literal::REVERSE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GearState &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GearState &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GearState &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GearState &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GearState &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GearState &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint8_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint8_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint8_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint8_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint8_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint8_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint8_t>(Literal::PARK): return "PARK";
            case static_cast< uint8_t>(Literal::DRIVE): return "DRIVE";
            case static_cast< uint8_t>(Literal::NORMAL): return "NORMAL";
            case static_cast< uint8_t>(Literal::REVERSE): return "REVERSE";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct UltrasonicNo : CommonAPI::Enumeration< uint8_t> {
        enum Literal : uint8_t {
            ULTRASONIC_1 = 0,
            ULTRASONIC_2 = 1,
            ULTRASONIC_3 = 2,
            ULTRASONIC_4 = 3,
            ALL = 4
        };
    
        UltrasonicNo()
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(Literal::ULTRASONIC_1)) {}
        UltrasonicNo(Literal _literal)
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint8_t>(Literal::ULTRASONIC_1):
                case static_cast< uint8_t>(Literal::ULTRASONIC_2):
                case static_cast< uint8_t>(Literal::ULTRASONIC_3):
                case static_cast< uint8_t>(Literal::ULTRASONIC_4):
                case static_cast< uint8_t>(Literal::ALL):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const UltrasonicNo &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const UltrasonicNo &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const UltrasonicNo &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const UltrasonicNo &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const UltrasonicNo &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const UltrasonicNo &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint8_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint8_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint8_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint8_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint8_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint8_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint8_t>(Literal::ULTRASONIC_1): return "ULTRASONIC_1";
            case static_cast< uint8_t>(Literal::ULTRASONIC_2): return "ULTRASONIC_2";
            case static_cast< uint8_t>(Literal::ULTRASONIC_3): return "ULTRASONIC_3";
            case static_cast< uint8_t>(Literal::ULTRASONIC_4): return "ULTRASONIC_4";
            case static_cast< uint8_t>(Literal::ALL): return "ALL";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct DoorPos : CommonAPI::Enumeration< uint8_t> {
        enum Literal : uint8_t {
            DOOR_FR = 0,
            DOOR_FL = 1,
            DOOR_RR = 2,
            DOOR_RL = 3,
            ALL = 4
        };
    
        DoorPos()
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(Literal::DOOR_FR)) {}
        DoorPos(Literal _literal)
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint8_t>(Literal::DOOR_FR):
                case static_cast< uint8_t>(Literal::DOOR_FL):
                case static_cast< uint8_t>(Literal::DOOR_RR):
                case static_cast< uint8_t>(Literal::DOOR_RL):
                case static_cast< uint8_t>(Literal::ALL):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const DoorPos &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const DoorPos &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const DoorPos &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const DoorPos &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const DoorPos &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const DoorPos &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint8_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint8_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint8_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint8_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint8_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint8_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint8_t>(Literal::DOOR_FR): return "DOOR_FR";
            case static_cast< uint8_t>(Literal::DOOR_FL): return "DOOR_FL";
            case static_cast< uint8_t>(Literal::DOOR_RR): return "DOOR_RR";
            case static_cast< uint8_t>(Literal::DOOR_RL): return "DOOR_RL";
            case static_cast< uint8_t>(Literal::ALL): return "ALL";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct DoorState : CommonAPI::Enumeration< uint8_t> {
        enum Literal : uint8_t {
            OPEN = 0,
            CLOSED = 1
        };
    
        DoorState()
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(Literal::OPEN)) {}
        DoorState(Literal _literal)
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint8_t>(Literal::OPEN):
                case static_cast< uint8_t>(Literal::CLOSED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const DoorState &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const DoorState &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const DoorState &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const DoorState &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const DoorState &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const DoorState &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint8_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint8_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint8_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint8_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint8_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint8_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint8_t>(Literal::OPEN): return "OPEN";
            case static_cast< uint8_t>(Literal::CLOSED): return "CLOSED";
            default: return "UNDEFINED";
            }
        }
    };
    struct S_DoorState : CommonAPI::Struct< DoorPos, DoorState> {
    
        S_DoorState()
        {
            std::get< 0>(values_) = DoorPos();
            std::get< 1>(values_) = DoorState();
        }
        S_DoorState(const DoorPos &_doorPos, const DoorState &_doorState)
        {
            std::get< 0>(values_) = _doorPos;
            std::get< 1>(values_) = _doorState;
        }
        inline const DoorPos &getDoorPos() const { return std::get< 0>(values_); }
        inline void setDoorPos(const DoorPos &_value) { std::get< 0>(values_) = _value; }
        inline const DoorState &getDoorState() const { return std::get< 1>(values_); }
        inline void setDoorState(const DoorState &_value) { std::get< 1>(values_) = _value; }
        inline bool operator==(const S_DoorState& _other) const {
        return (getDoorPos() == _other.getDoorPos() && getDoorState() == _other.getDoorState());
        }
        inline bool operator!=(const S_DoorState &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct S_UltrasonicState : CommonAPI::Struct< UltrasonicNo, float> {
    
        S_UltrasonicState()
        {
            std::get< 0>(values_) = UltrasonicNo();
            std::get< 1>(values_) = 0.0f;
        }
        S_UltrasonicState(const UltrasonicNo &_ultrasonic, const float &_value)
        {
            std::get< 0>(values_) = _ultrasonic;
            std::get< 1>(values_) = _value;
        }
        inline const UltrasonicNo &getUltrasonic() const { return std::get< 0>(values_); }
        inline void setUltrasonic(const UltrasonicNo &_value) { std::get< 0>(values_) = _value; }
        inline const float &getValue() const { return std::get< 1>(values_); }
        inline void setValue(const float &_value) { std::get< 1>(values_) = _value; }
        inline bool operator==(const S_UltrasonicState& _other) const {
        return (getUltrasonic() == _other.getUltrasonic() && getValue() == _other.getValue());
        }
        inline bool operator!=(const S_UltrasonicState &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct Coordinates : CommonAPI::Struct< float, float> {
    
        Coordinates()
        {
            std::get< 0>(values_) = 0.0f;
            std::get< 1>(values_) = 0.0f;
        }
        Coordinates(const float &_latitude, const float &_longitude)
        {
            std::get< 0>(values_) = _latitude;
            std::get< 1>(values_) = _longitude;
        }
        inline const float &getLatitude() const { return std::get< 0>(values_); }
        inline void setLatitude(const float &_value) { std::get< 0>(values_) = _value; }
        inline const float &getLongitude() const { return std::get< 1>(values_); }
        inline void setLongitude(const float &_value) { std::get< 1>(values_) = _value; }
        inline bool operator==(const Coordinates& _other) const {
        return (getLatitude() == _other.getLatitude() && getLongitude() == _other.getLongitude());
        }
        inline bool operator!=(const Coordinates &_other) const {
            return !((*this) == _other);
        }
    
    };
};

const char* Perception::getInterface() {
    return ("coda.vehicle.Perception:v1_0");
}

CommonAPI::Version Perception::getInterfaceVersion() {
    return CommonAPI::Version(1, 0);
}


} // namespace vehicle
} // namespace coda
} // namespace v1

namespace CommonAPI {
}


// Compatibility
namespace v1_0 = v1;

#endif // V1_CODA_VEHICLE_PERCEPTION_HPP_
